/****************************************com.lxd.*****************************************************
**                            YBU  LXD
**
**                             
**--------------------------------------------------------------------------------------------------------
** Modify by:           
** Modified date:       2020 10 12
** Version:             V1.1.1
** Descriptions:        Test
**--------------------------------------------------------------------------------------------------------
*********************************************************************************************************/

#include "Dobot.h"
#include <SPI.h>
#include "Pixy2.h"
#include "Protocol.h"
//初始位置，既摄像头检测物块位置
#define Init_position_X -3.5968
#define Init_position_Y 194.6124
#define Init_position_Z 49.9314
#define Init_position_R 95

//物块在传送带的位置
#define block_position_X -9.6609    //物体在传送带上对于机械臂X轴的坐标
#define block_position_Y 275.0335  //物体在传送带上对于机械臂Y轴的坐标
#define block_position_Z 11.5438  //物体在传送带上对于机械臂Z轴的坐标
#define block_position_R 89.6295       //物体在传送带上对于机械臂R轴的坐标

//物块的放置位置（翻斗小车）
#define des_position_X 25   //物体对于翻斗模块的X轴坐标
#define des_position_Y -193 //物体对于翻斗模块的Y轴坐标
#define des_position_Z 97   //物体对于翻斗模块的Z轴坐标
#define des_position_R 13   //物体对于翻斗模块的R轴坐标

//过渡点位置（机械臂摆动角度太大时会丢步）
#define tmp_position_X1 190 //  过渡点X坐标
#define tmp_position_Y1 186 //  过渡点Y坐标
#define tmp_position_Z1 97  //  过渡点Z坐标
#define tmp_position_R1 88

//过渡点位置（机械臂摆动角度太大时会丢步）
#define tmp_position_X2 232 //  过渡点X坐标
#define tmp_position_Y2 -36 //  过渡点Y坐标
#define tmp_position_Z2 97  //  过渡点Z坐标
#define tmp_position_R2 1

//过渡点位置（机械臂摆动角度太大时会丢步）
#define tmp_position_X3 126  //  过渡点X坐标
#define tmp_position_Y3 -173 //  过渡点Y坐标
#define tmp_position_Z3 97   //  过渡点Z坐标
#define tmp_position_R3 10



#define standard_x 150//物体x位置
#define standard_y  100//物体y
#define P 0.4//比例



Pixy2 pixy; //定义摄像头对象，调用pixy
Block b_l;
double arr_x[6] = {198.732, 253.2497, 200.474, 259.4758, 200.4471, 262.5647};
double arr_y[6] = {112.2621, 119.0274, 43.7427, 44.545, -18.6591, -17.7374};
double arr_z[6] = {-44.4366, -41.6185, -44.0244, -44.0982, -40.1265, -44.5058};
int arr_block[6] = {0, 0, 0, 0, 0, 0};

//发送字符串的函数
void Send_ok(char c)
{
  for (int i = 0; i < 10; i++)
  {
    Serial2.write(c);
  }
}

int Get_glaxy()
{
  return digitalRead(46);
}

void Update_blocks(){
  delay(400);
  pixy.ccc.getBlocks();
  
}
void send_color(int i){
    Serial.println(i);
  switch (i){

    case 1:
    for(int j=0;j<100;j++){
    Serial2.write("R");
    }
    break;
    case 2: 
    
    Serial2.write("G"); 
    delay(100);
     
    break;
    case 3:
     for(int j=0;j<100;j++){
     Serial2.write("B"); 
     }
    break;
    case 4: 
     for(int j=0;j<10;j++){
    Serial2.write("Y"); 
     }
    break;
    
  }

  Serial.println("SEND oK");
}
void Put_Car(int K)
{

  Dobot_SetPTPCmd(JUMP_XYZ, block_position_X + K * P , block_position_Y, block_position_Z, block_position_R);
  Dobot_SetEndEffectorSuctionCup(true);
  Dobot_SetPTPCmd(MOVJ_XYZ, tmp_position_X1, tmp_position_Y1, tmp_position_Z1, tmp_position_R1);
  Dobot_SetPTPCmd(JUMP_XYZ, des_position_X, des_position_Y, des_position_Z, des_position_R);
  Dobot_SetEndEffectorSuctionCup(false);
  Dobot_SetPTPCmd(MOVJ_XYZ, tmp_position_X1, tmp_position_Y1, tmp_position_Z1, tmp_position_R1);
}

void back_init()
{
  Dobot_SetPTPCmd(MOVJ_XYZ, tmp_position_X1, tmp_position_Y1, tmp_position_Z1, tmp_position_R1);
  Dobot_SetPTPCmd(JUMP_XYZ, Init_position_X, Init_position_Y, Init_position_Z, Init_position_R);
  // Dobot_SetPTPCmd(JUMP_XYZ, Init_position_X, Init_position_Y, Init_position_Z, Init_position_R);
}

void Put_Car_from_Map(int i)
{

  Dobot_SetPTPCmd(JUMP_XYZ, arr_x[i], arr_y[i], arr_z[i], 0);
  Dobot_SetEndEffectorSuctionCup(true);
  Dobot_SetPTPCmd(JUMP_XYZ, des_position_X, des_position_Y, des_position_Z, des_position_R);
  Dobot_SetEndEffectorSuctionCup(false);
}

void P_M_T_C(int a, int b)
{ //地图上面拿2个一样的元素
  Dobot_SetPTPCmd(MOVJ_XYZ, tmp_position_X1, tmp_position_Y1, tmp_position_Z1, tmp_position_R1);
  Dobot_SetPTPCmd(JUMP_XYZ, arr_x[a], arr_y[a], arr_z[a], 0);
  Dobot_SetEndEffectorSuctionCup(true);
  Dobot_SetPTPCmd(JUMP_XYZ, des_position_X, des_position_Y, des_position_Z, des_position_R);
  Dobot_SetEndEffectorSuctionCup(false);
  Dobot_SetPTPCmd(JUMP_XYZ, arr_x[b], arr_y[b], arr_z[b], 0);
  Dobot_SetEndEffectorSuctionCup(true);
  Dobot_SetPTPCmd(JUMP_XYZ, des_position_X, des_position_Y, des_position_Z, des_position_R);
  Dobot_SetEndEffectorSuctionCup(false);
  
}


void Put_Map(int color, int K)
{
  int i = 0;
  while (1)
  {
    if (!arr_block[i])
    {
      arr_block[i] = color;
      break;
    }
    i++;
  }

  
  Dobot_SetPTPCmd(JUMP_XYZ, block_position_X + K * P, block_position_Y, block_position_Z, block_position_R);
  Dobot_SetEndEffectorSuctionCup(true);
  Dobot_SetPTPCmd(JUMP_XYZ, arr_x[i], arr_y[i], arr_z[i], 0);
  Dobot_SetEndEffectorSuctionCup(false);
  Dobot_SetPTPCmd(JUMP_XYZ, Init_position_X, Init_position_Y, Init_position_Z, Init_position_R);
//  Serial.println("I");
//  Serial.println(arr_block[i]);
}
void setup()
{
  Serial.begin(115200); //主控板的串口波特率
  Dobot_Init();         //主板初始化
  pixy.init();          //摄像头初始化
  Serial.println("Initialization completed...\n");
  Dobot_SetPTPCommonParams(300, 300);                                                            //设置机械臂运动比例（机械臂运行速度
  Dobot_SetPTPLParams(300,300);
  Dobot_SetPTPJointParams(200,200,200,200,200,200,200,200);
  Dobot_SetJOGCoordinateParams(200,200,200,200,200,200,200,200);
   Dobot_SetPTPJointParams(200,200,200,200,200,200,200,200);
  Dobot_SetPTPCmd(JUMP_XYZ, Init_position_X, Init_position_Y, Init_position_Z, Init_position_R); //机械臂移动到物块检测位置
  Serial.println("Starting...\n");
  Serial2.begin(9600);
  pinMode(46, LOW);
//     pinMode(35,OUTPUT);
//      while(1){
//    if(!digitalRead(35)){
//      
//    break;
//    }
//    Serial.println("wait ");
//  }
 
  delay(1000);
}



void loop()
{
  //Serial.println(arr_block[0]);
  uint16_t blocks;
  pixy.ccc.getBlocks(); //检测物块，获取物块信息
  delay(10);
  pixy.ccc.getBlocks();
  delay(10);
  pixy.ccc.getBlocks(); //多次检测
  delay(10);
  blocks = pixy.ccc.numBlocks; //物块信息使能判断，有对应颜色物块时返回1，反回0
  pixy.ccc.blocks[0].print();

  if (!Get_glaxy())
  {
    int tmp = -1;
    int i = 0;
    int count = 0;
    while (i < 6)
    {
      if (arr_block[i] == 0)
        count++;
      i++;
    }
    int flag = 1;
    if (count == 6)
    {
      flag = 0;
    }

    if (flag)
    { //数组非空
      int index = 0;
      int i_index = 0;
      int map_order[2] = {-1, -1};
      int idlenly = 0;
      int  tmp_t = 0;
      int i_flag = 0;
      while (index < 6)
      {
        tmp_t = arr_block[index];
       
       // delay(1000);
        i_index = index + 1;
        while (i_index < 6)
        {
          if (tmp_t != 0 && tmp_t == arr_block[i_index])
          {
//             Serial.println("tmp");
//             Serial.println(tmp_t);
//             Serial.println("now");
//             Serial.println(arr_block[i_index]);
            tmp = tmp_t;
            map_order[0] = index;
            map_order[1] = i_index;
            arr_block[index] = 0;
            arr_block[i_index] = 0;
            idlenly = 1;
            i_flag = 1;
            break;
          }
          i_index++;
        }
        if(i_flag){
          break;
          }
        
        index++;
      }
//      Serial.println("idlenly");
//      Serial.println(idlenly);

      int k_index = 0;
      int map_t = 0;
      int flag_t = 0;

      if (idlenly)
      { //地图上面拿给小车
        //Serial.println("num has same color box");

        P_M_T_C(map_order[0], map_order[1]);
        send_color(tmp);
        back_init();
      }

      else
      { //没有相同方块 找出是否存在和当前物块颜色一样的方快

        while (k_index < 6)
        {
         // Serial.println(blocks);
          
          if (blocks)
          { //物块到了
            if (pixy.ccc.blocks[0].m_signature == arr_block[k_index]   && arr_block[k_index] != 0)
            {
              flag_t = 1;
              map_t = k_index;
              tmp = arr_block[k_index];
              arr_block[k_index] = 0;
              break;
            }
          }
          else
          {                              //物块没到
            if (arr_block[k_index]!=0){ //直接在数组里面拿一个{
            map_t = k_index;
            tmp = arr_block[k_index];
            arr_block[k_index] = 0;
            break;
          }
          }

          k_index++;
        }

        if (blocks)
        { //传送带物块存在

          if (flag_t)
          {
            //取传送带 和地图
            Update_blocks();
            Put_Car(pixy.ccc.blocks[0].m_x - standard_x);
            Put_Car_from_Map(map_t);
            send_color(tmp);
            back_init();
            // Serial.println("take  c  and  map");
            // delay(5000);
          }

          else
          {
            //数组里面没有和当前一样的颜色 传送带上面拿
            // Serial.println("map not c");
            // delay(5000);
            Update_blocks();
            Put_Car(pixy.ccc.blocks[0].m_x - standard_x);
            send_color(tmp);
            back_init();
          }
        }
        else
        { //传送带是空 只有数组里面有 数组里面拿
//          Serial.println("arr has not some box ");
//          delay(1000);
          Put_Car_from_Map(map_t);
          send_color(tmp);
          back_init();
        }
      }
    }
    else
    { //数组是空
      //检测2次
      int x = 0; 
      if(blocks){
      tmp = pixy.ccc.blocks[0].m_signature;
      Update_blocks();
      Put_Car(pixy.ccc.blocks[0].m_x - standard_x);
      x = 1;
      }
      //Put_Car(int K);
      // Serial.println(pixy.ccc.blocks[0].m_signature);
      // Serial.println("wait");
      // delay(5000);
      pixy.ccc.getBlocks(); //检测物块，获取物块信息
      delay(10);
      pixy.ccc.getBlocks();
      delay(10);
      pixy.ccc.getBlocks(); //多次检测
      delay(10);
      blocks = pixy.ccc.numBlocks; //物块信息使能判断，有对应颜色物块时返回1，反回0
     //  Serial.println(pixy.ccc.blocks[0].m_signature);
      if (blocks)
      {
        if (pixy.ccc.blocks[0].m_signature == tmp)
        {
          Update_blocks();
          Put_Car(pixy.ccc.blocks[0].m_x - standard_x);
          x = 0;
          send_color(tmp);
          back_init();
          
        }
        
      }

      if(x){

        send_color(tmp);
         back_init();
      }

  
    }
  }
  else
  {

    if (blocks)
    {
      Update_blocks();
      Put_Map(pixy.ccc.blocks[0].m_signature, pixy.ccc.blocks[0].m_x - standard_x);
    }
    //放地图
  }
}
